---
title: "Intro to QC Notes"
date: 2025-09-28
permalink: /posts/2025/09/qc-notes/
tags:
  - quantum
  - qubits
  - gates
  - algorithms
---

## Bloch Sphere

A two level system could be expressed as 

$$
\ket{\psi}=\alpha \ket0+\beta\ket 1,\quad |\alpha|^2+|\beta|^2=1
$$

$$
\ket\psi=\cos\frac\theta2\ket0+e^{i\phi}\sin\frac\theta2\ket1
$$

## Energy Uncertainty

$$
\Delta E\Delta t\ge\frac\hbar2\quad\Delta E=\hbar\Delta\omega\qquad\Rightarrow \Delta \omega\propto\frac1{\Delta t}
$$

Qubit Phase $\phi=2\pi ft$ fluctuation lead to decoherence.

---

## Single-Qubit Gates

### Rotation

$$
\begin{equation}R_x(\theta) \equiv X_\theta \equiv e^{-i\theta\sigma_x/2} = \begin{pmatrix}\cos \frac{\theta}{2} & -i \sin \frac{\theta}{2} \\-i \sin \frac{\theta}{2} & \cos \frac{\theta}{2}\end{pmatrix}\end{equation}\\
\begin{equation}R_y(\theta) \equiv Y_\theta \equiv e^{-i\theta\sigma_y/2} = \begin{pmatrix}\cos \frac{\theta}{2} & -\sin \frac{\theta}{2} \\\sin \frac{\theta}{2} & \cos \frac{\theta}{2}\end{pmatrix}\end{equation}\\
\begin{equation}R_z(\theta) \equiv Z_\theta \equiv e^{-i\theta\sigma_z/2} = \begin{pmatrix}e^{-i\theta/2} & 0 \\0 & e^{i\theta/2}\end{pmatrix}\end{equation}
$$

Rotation about any axis,

$$
\begin{equation}R_{\hat{n}}(\theta) \equiv \exp\left(-i \theta \, \hat{n} \cdot \frac{\vec{\sigma}}{2}\right) = \cos\frac{\theta}{2} I \; - \; i \sin\frac{\theta}{2} \left( n_x \sigma_x + n_y \sigma_y + n_z \sigma_z \right)\end{equation}
$$

### Pauli-X (Bit-flip gate / NOT gate)

Matrix: $X = \begin{pmatrix}0 & 1 \\ 1 & 0\end{pmatrix}$
Action: $X|0\rangle = |1\rangle, \quad X|1\rangle = |0\rangle$

Interpretation: π rotation around **x-axis**

### Hadamard Gate (H)

Matrix: $H = \tfrac{1}{\sqrt{2}}\begin{pmatrix}1 & 1 \\ 1 & -1\end{pmatrix}$

Action: $H|0\rangle = \tfrac{|0\rangle + |1\rangle}{\sqrt{2}}$

Interpretation: Creates superposition, reflection across x–z plane axis

### Pauli-Z (Phase-flip gate / Z gate)

Matrix: $Z = \begin{pmatrix}1 & 0 \\ 0 & -1\end{pmatrix}$

Action: $Z|0\rangle = |0\rangle, Z|1\rangle = -|1\rangle$

Interpretation: π rotation around **z-axis**

### Phase Gate (S)

Matrix: $S = \begin{pmatrix}1 & 0 \\ 0 & i\end{pmatrix}$

Property: $S^2 = Z$

Interpretation: π/2 rotation around **z-axis**

### T Gate (π/8 Gate)

Matrix: $T = \begin{pmatrix}1 & 0 \\ 0 & e^{i\pi/4}\end{pmatrix}$

Property: $T^2 = S$

Interpretation: π/4 rotation around **z-axis**

## Two-Qubit Gates

### Tensor Products

Two-qubit gates act on **4D Hilbert space**.

Simultaneous application of Hadamard (on qubit 1) and Phase gate (on qubit 2):

$$
 H \otimes S = \frac{1}{\sqrt{2}}
\begin{pmatrix}
1 \times
\begin{pmatrix}1 & 0 \\ 0 & i\end{pmatrix} &
1 \times
\begin{pmatrix}1 & 0 \\ 0 & i\end{pmatrix} \\
1 \times
\begin{pmatrix}1 & 0 \\ 0 & i\end{pmatrix} &
-1 \times
\begin{pmatrix}1 & 0 \\ 0 & i\end{pmatrix}
\end{pmatrix}
= \frac{1}{\sqrt{2}}
\begin{pmatrix}
1 & 0 & 1 & 0 \\
0 & i & 0 & i \\
1 & 0 & -1 & 0 \\
0 & i & 0 & -i
\end{pmatrix}
$$

### CNOT (Controlled-NOT)

$$

\mathrm{CNOT} = |0\rangle\langle 0| \otimes I 
+ |1\rangle\langle 1| \otimes X
=
\begin{pmatrix}
1 & 0 \\ 0 & 0
\end{pmatrix} \otimes 
\begin{pmatrix}
1 & 0 \\ 0 & 1
\end{pmatrix}
+
\begin{pmatrix}
0 & 0 \\ 0 & 1
\end{pmatrix} \otimes 
\begin{pmatrix}
0 & 1 \\ 1 & 0
\end{pmatrix}
=
\begin{pmatrix}
1 & 0 & 0 & 0 \\
0 & 1 & 0 & 0 \\
0 & 0 & 0 & 1 \\
0 & 0 & 1 & 0
\end{pmatrix}
$$

Action: flips target qubit **if control qubit = 1,** Creates entanglement (e.g. from $|00\rangle + |10\rangle$)

### CPHASE (Controlled-Z)

$$

\mathrm{CPHASE} = |0\rangle\langle 0| \otimes I 
+ |1\rangle\langle 1| \otimes Z
=
\begin{pmatrix}
1 & 0 \\ 0 & 0
\end{pmatrix} \otimes 
\begin{pmatrix}
1 & 0 \\ 0 & 1
\end{pmatrix}
+
\begin{pmatrix}
0 & 0 \\ 0 & 1
\end{pmatrix} \otimes 
\begin{pmatrix}
1 & 0 \\ 0 & -1
\end{pmatrix}
=
\begin{pmatrix}
1 & 0 & 0 & 0 \\
0 & 1 & 0 & 0 \\
0 & 0 & 1 & 0 \\
0 & 0 & 0 & -1
\end{pmatrix}
$$

Action: applies $Z$ gate to target if control = 1

### iSWAP

$$

i\mathrm{SWAP} = |00\rangle\langle 00| + |11\rangle\langle 11|
+ i |01\rangle\langle 10| + i |10\rangle\langle 01|
=
\begin{pmatrix}
1 & 0 & 0 & 0 \\
0 & 0 & i & 0 \\
0 & i & 0 & 0 \\
0 & 0 & 0 & 1
\end{pmatrix}
$$

Swaps $|01\rangle \leftrightarrow i|10\rangle$, Can be implemented via capacitive coupling

### √iSWAP

$$

\sqrt{i\mathrm{SWAP}} =
|00\rangle\langle 00| + |11\rangle\langle 11|
+ \tfrac{1}{\sqrt{2}}(|01\rangle\langle 01| + |10\rangle\langle 10|)
- \tfrac{i}{\sqrt{2}}(|01\rangle\langle 10| + |10\rangle\langle 01|)
=
\begin{pmatrix}
1 & 0 & 0 & 0 \\
0 & \tfrac{1}{\sqrt{2}} & -\tfrac{i}{\sqrt{2}} & 0 \\
0 & -\tfrac{i}{\sqrt{2}} & \tfrac{1}{\sqrt{2}} & 0 \\
0 & 0 & 0 & 1
\end{pmatrix}
$$

Generates entangled Bell-like states (e.g. $|01\rangle + i|10\rangle$)

### Universal Gate Sets

A universal set can be:

$$
\{X_\theta, Y_\theta, Z_\theta, \text{Ph}_\theta, \text{CNOT}\}
$$

$$
\{H, S, T, \text{CNOT}\}
$$

---

## Gate Fidelity

When a quantum system is in the state $|\psi\rangle$ and a noisy physical process $\varepsilon$ occurs, the system evolves to $\varepsilon(|\psi\rangle\langle\psi|)$. Ideally, the target gate is a unitary operation $U$. To measure how close the noisy process is to the ideal gate, we compute the **average gate fidelity**, which is the average overlap between the noisy output and the ideal output over all input states:

$$
F_{\mathrm{avg}}(\varepsilon, U)
= \int d\psi \; \langle \psi | U^{\dagger} \, \varepsilon\!\left(|\psi\rangle\langle\psi|\right) U | \psi \rangle
$$

In short: **$F_{\text{avg}}$ quantifies how accurately the real process matches the ideal gate, averaged over all possible input states.** The coherence time, or the duration that a qubit can remain coherent and retain quantum information, determines the number of quantum gates or qubit operations that can be applied to the qubit.

## Evaluating the Performance of a Quantum Processor

### 1. Double-π (π–π) Metric

- Apply two π pulses in succession → ideally gives the identity operation.
- Deviations from identity show errors:
    - Leakage to higher energy levels,
    - Qubit relaxation.
- Provides a *rough* estimate of fidelity, but:
    - Cannot capture all error types,
    - Not sensitive to errors in eigenstates of σx, σy, or small angle variations.

### 2. Quantum Process Tomography (QPT)

- Goal: reconstruct the **process matrix** χ describing the gate.
- Steps:
    1. Apply input pulses from {I, Rx(π), Rx(π/2), Ry(π/2)} to prepare basis states.
    2. Apply the process under study.
    3. Perform state tomography using final rotations.
- Can fully characterize single-qubit gates.
- Limitations:
    - Requires many measurements (scales exponentially with qubit number).
    - Sensitive to **measurement errors** (hard to distinguish gate error from SPAM error).

### 3. Randomized Benchmarking (RB)

- Apply random sequences of Clifford group gates ($R_u = e^{i\sigma_u \pi/4}, u = x,y$).
- Track how fidelity decays as circuit length increases.
- Advantages:
    - Isolates gate errors from measurement/SPAM errors (error differences cancel SPAM).
    - Efficient for many qubits (less resource-intensive than QPT).
- Output: average gate fidelity as a function of circuit length.

### Comparison

- **π–π metric**: simple, quick, but rough.
- **QPT**: complete characterization, but expensive and SPAM-sensitive.
- **RB**: scalable, robust to SPAM, widely used in experiments.

---

## Quantum Algorithms

### General Structure

A quantum algorithm typically involves four steps:

1. **Create superposition:** Use Hadamard gates to put qubits into equal superpositions.
2. **Encode function:** Apply a unitary $U_f$ that encodes a classical function $f(x)$:
    
    $$
    U_f : |x\rangle|y\rangle \mapsto |x\rangle |y \oplus f(x)\rangle
    $$
    
3. **Process:** Apply further single- and multi-qubit gates ($U_p$) to manipulate information and exploit interference.
4. **Measure:** Collapse qubits to classical bits to obtain the result.

### Example: Evaluating f(x)

- Start with qubits in $|0\rangle$.
- Apply Hadamard gates to create a uniform superposition over all inputs:
    
    $$
    (H \otimes H)|00\rangle = \tfrac{1}{2} (|00\rangle + |01\rangle + |10\rangle + |11\rangle)
    
    $$
    
- Apply $U_f$ once:
    
    $$
    U_f \tfrac{1}{2}(|00\rangle + |01\rangle + |10\rangle + |11\rangle)|0\rangle
    = \tfrac{1}{2}(|00,f(00)\rangle + |01,f(01)\rangle + |10,f(10)\rangle + |11,f(11)\rangle)
    $$
    
- The output register contains **all function values in parallel**.
- Quantum interference (via extra unitaries) is then used to extract the correct answer efficiently.

### Famous Quantum Algorithms

- **Grover’s Algorithm**
    - Quantum search: finds a marked item in $O(\sqrt{N})$ queries instead of $O(N)$.
- **Shor’s Algorithm**
    - Integer factorization exponentially faster than best classical methods.
    - Breaks RSA encryption assumptions.
- **Deutsch–Jozsa Algorithm**
    - Early example showing exponential quantum advantage for specific problems.
- **Quantum Fourier Transform (QFT)**
    - Quantum version of classical Fourier transform.
    - A core tool in many algorithms, including Shor’s.

### Deutsch’s Algorithm

We are given a function $f: \{0,1\}^n \to \{0,1\}$, implemented as a quantum oracle.

The function is guaranteed to be either:

- **Constant**: outputs the same value for all inputs.
- **Balanced**: outputs 0 for half the inputs and 1 for the other half.

**Goal:** Determine whether $f$ is constant or balanced using only one query.

1. Start with two qubits in state: $|0\rangle|1\rangle$
2. Apply a **Hadamard transform** $H$ to each qubit:
$(|0\rangle + |1\rangle)(|0\rangle - |1\rangle)/\sqrt{2}$
3. Apply the **oracle gate** $U_f : |x\rangle|y\rangle \mapsto |x\rangle|y \oplus f(x)\rangle$:
    
    $$
    \frac{1}{2}\Big(|0\rangle(|f(0)\oplus 0\rangle - |f(0)\oplus 1\rangle)
    
    |1\rangle(|f(1)\oplus 0\rangle - |f(1)\oplus 1\rangle)\Big)
    
    $$
    
    Simplifies to: (the second qubit can be ignored)
    
    $$
    \frac{1}{\sqrt{2}}\big(|0\rangle + (-1)^{f(0)\oplus f(1)}|1\rangle\big)\otimes \frac{|0\rangle - |1\rangle}{\sqrt{2}}
    $$
    
4. Apply a **Hadamard transform** again to the first qubit:
    
    $$
    
    \frac{1}{2}\Big(\big(1 + (-1)^{f(0)\oplus f(1)}\big)|0\rangle
    
    \big(1 - (-1)^{f(0)\oplus f(1)}\big)|1\rangle\Big)
    
    $$
    
- If $f(0) \oplus f(1) = 0$: output is $|0\rangle$ → **constant function**.
- If $f(0) \oplus f(1) = 1$: output is $|1\rangle$ → **balanced function**.

---

## Quantum Error Correction

Quantum systems are prone to **errors** from decoherence, thermal noise, or quasiparticle poisoning. Errors must be corrected to achieve **fault-tolerant quantum computation**.

Unlike classical bits (only bit-flip errors), quantum bits suffer from:

**Bit-flip error:** $|0\rangle \leftrightarrow |1\rangle$

**Phase-flip error:** phase of qubit changes, 
e.g. Expected: $\alpha|0\rangle + \beta e^{i\phi}|1\rangle$ , Error: $\alpha|0\rangle + \beta e^{i(\phi+\delta)}|1\rangle$

### Error-Correcting Codes

- **Bit-flip code** and **phase-flip code** can correct respective errors.
- More advanced codes (e.g., surface code) protect against both simultaneously.

### Threshold Theorem

- States that if gate error rates are **below a critical threshold**, logical error rates can be suppressed arbitrarily with error correction.
- Example: surface code requires **≥ 99% gate fidelity**.
- Modern experiments achieve > 99% with 1–2 qubit gates on several platforms.

### Encoding and Overhead

- A single **logical qubit** is encoded in **multiple physical qubits**.
- Extra qubits are used for error detection and correction (like parity checks in classical codes).
- **Quantum Hamming bound:** at least **5 physical qubits** are needed for arbitrary correction of 1 logical qubit.
- Known codes use **5, 7, or 9 qubits** per logical qubit.
- This large overhead is a major challenge for scalable quantum computing.

## Quantum Computing Platforms

Key requirement: trapping, controlling, and reading out the qubits.

Control methods include lasers, microwaves, and magnetic fields.

### Ions

- Electronic energy levels of an ion (e.g. hyperfine or Zeeman states). Example: ytterbium ion
- Ions are charged atoms → can be trapped with electric fields.
- Controlled with **lasers** (for initialization, gate operations, and readout).
- Advantage: very long coherence times and high gate fidelities.

### Neutral Atoms

- Internal electronic states of neutral atoms (e.g. rubidium or cesium).
- Trapping via **magneto-optical traps (MOTs)**, **Doppler cooling**, or **optical tweezers**.
- Entanglement: induced by exciting atoms into **Rydberg states** with light pulses.
- Advantage: large arrays of atoms can be trapped without dilution refrigerators.

### Spin Qubits

- Electron spin states (spin-up $\ket\uparrow$, spin-down $\ket\downarrow$).
- Implemented in **quantum dots** formed in a 2D electron gas.
- Controlled with electric/magnetic fields.
- Readout via **spin-to-charge conversion**.

### Superconducting Qubits

- Lowest two energy levels of an **artificial atom** (e.g. transmon).
- Built from superconducting circuits with Josephson junctions.
- Controlled by **microwave pulses**; readout via **cavity QED** (frequency shifts).
- Operate at microwave frequencies (4–8 GHz), inside dilution fridges.

### Topological Qubits

- Encoded nonlocally in **topological states of matter** (non-Abelian anyons, e.g. Majorana modes).
- Advantage: inherently immune to local noise and decoherence.
- Status: still experimental; Majorana signatures observed, but no working topological qubit yet.

## Technical Challenges of Scaling

Modern quantum computers operate with a few hundred qubits, but **scaling to thousands/millions** is required. Challenges affect all platforms, but semiconductor qubits highlight these issues.

### Noise and Crosstalk

- **Noise sources:** stray EM fields, cosmic radiation, thermal fluctuations, coupling from control lines. More qubits → more cables → more noise pickup.
- **Crosstalk:** inductive/capacitive coupling between lines causes correlated errors across qubits.

### Input/Output (IO) Management

- Classical computers can fan-out signals; quantum gates cannot (no-cloning theorem).
- Each qubit requires its **own IO line** → scaling challenge.
- Requires careful interconnects, cabling, packaging, multiplexing strategies.
- Extra constraint: magnet bore diameter limits connector density (important for spin and topological qubits).

### Heat and Power Dissipation

- More qubits → more cables → more heat entering the dilution fridge.
- Attenuators reduce noise but add thermal load.
- Qubits also release heat during operation.
- Cooling at millikelvin temperatures is limited (milliwatts).
- Solutions: operate some qubits (e.g., spin qubits) above 1K; still, superconducting qubits must remain at mK.

### Size of the System

- Larger systems = longer transmission lines.
- Issues: **Phase shifts** between signals (harder to synchronize). **Propagation delays** (tens of ns), comparable to gate times.
- Requires integrated architectures to minimize path lengths, improve integrity, and reduce power.

### Slew Rate, Rise Time, Bandwidth

- Control pulses need sufficient bandwidth to avoid distortion.
- Signals attenuated 50–60 dB before reaching qubits → require strong generators/amplifiers.
- Millivolt amplitudes and **picosecond rise times** needed at qubits.
- Standard CMOS can provide fast pulses; Cryo-CMOS solutions (chips inside fridge) are proposed for scalability.

---

## Skillsets for Quantum Hardware Engineers

### Cryogenic Engineering

- Qubits need **10–50 mK** operation to suppress noise.
- Knowledge of **dilution refrigerators** and cold environments is essential.
- Tasks: identify/mitigate noise paths (conducted/radiated).
- Tools: filters, circulators, attenuators, shielding, lossy cables.

### Microwave Engineering

- Qubit control/readout happens at RF and microwave frequencies.
- Engineers need knowledge of both **cryogenic** and **room-temperature** microwave systems.
- Skills include: Noise suppression. Use of network/spectrum analyzers. Microwave signal processing (amplification, conversion, filtering).
- Essential for sending/receiving qubit control signals.

### Nanofabrication

- High-quality qubits require advanced **lithography and deposition**.
- Techniques: electron-beam lithography, sputtering, thermal evaporation.

### Data Acquisition

- Final stage: acquire qubit data and send to computers for postprocessing.
- Skills: Communication protocols: GPIB, TCP/IP, USB, serial.
    
    Software tools: MATLAB, Python, QCoDeS, pyCQED, qKIT, Labber.
    
- Engineers must synchronize instruments and automate experiments.